{"version":3,"sources":["file:///Users/super_javan/cocoscreator/CrampedRoomOfDeathDungeon/assets/Scripts/Player/PlayerMgr.ts"],"names":["Component","_decorator","Sprite","UITransform","SpriteAtlas","ResourceLoadMgr","ccclass","property","PlayerMrg","init","spriteAtlas","Instance","loadRes","sprite","addComponent","transform","node","getComponent"],"mappings":";;;;;;;;;;;;;;;;AAASA,MAAAA,S,OAAAA,S;AAAWC,MAAAA,U,OAAAA,U;AAAkBC,MAAAA,M,OAAAA,M;AAAQC,MAAAA,W,OAAAA,W;AAAwBC,MAAAA,W,OAAAA,W;;AAI/DC,MAAAA,e;;;;;;;;;OAMD;AAAEC,QAAAA,OAAF;AAAWC,QAAAA;AAAX,O,GAAwBN,U;;2BAEjBO,S,WADZF,OAAO,CAAC,WAAD,C,gBAAR,MACaE,SADb,SAC+BR,SAD/B,CACyC;AAC3B,cAAJS,IAAI,GAAG;AACT,gBAAMC,WAAW,GAAG,MAAM;AAAA;AAAA,kDAAgBC,QAAhB,CAAyBC,OAAzB,CAAiC,CAAC,yBAAD,CAAjC,EAA8DR,WAA9D,CAA1B;AACA,gBAAMS,MAAM,GAAG,KAAKC,YAAL,CAAkBZ,MAAlB,CAAf;AACA,gBAAMa,SAAS,GAAG,KAAKC,IAAL,CAAUC,YAAV,CAAuBd,WAAvB,CAAlB,CAHS,CAKT;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACH;;AA/BoC,O","sourcesContent":["import { Component, _decorator, Node, Sprite, UITransform, Animation, SpriteAtlas } from \"cc\";\nimport { ENUM_EVENT } from \"../../Enum\";\nimport levels, { ILevel } from \"../../Levels\";\nimport EventMgr from \"../Base/EventMgr\";\nimport ResourceLoadMgr from \"../Base/ResourceLoadMgr\";\nimport DataManager from \"../Runtime/DataManager\";\n// import { DataManager.Instance } from \"../Runtime/DataManager\";\nimport { TileMapManager } from \"../TileMap/TileMapManager\";\nimport { createNewNode } from \"../Utils\";\n\nconst { ccclass, property } = _decorator;\n@ccclass('PlayerMrg')\nexport class PlayerMrg extends Component {\n    async init() {\n        const spriteAtlas = await ResourceLoadMgr.Instance.loadRes(['texture/player/idle/top'], SpriteAtlas)\n        const sprite = this.addComponent(Sprite)\n        const transform = this.node.getComponent(UITransform)\n\n        // const animationClip = new AnimationClip();\n        // animationClip.duration = 1.0; // 整个动画剪辑的周期\n\n        // const track = new animation.VectorTrack(); // 创建一个向量轨道\n        // track.componentsCount = 3; // 使用向量轨道的前三条通道\n        // track.path = new animation.TrackPath().toHierarchy('Foo').toProperty('position'); // 指定轨道路径，即指定目标对象为 \"Foo\" 子节点的 \"position\" 属性\n        // const [x, y, z] = track.channels(); // x, y, z 是前三条通道\n        // x.curve.assignSorted([ // 为 x 通道的曲线添加关键帧\n        //     [0.4, ({ value: 0.4 })],\n        //     [0.6, ({ value: 0.6 })],\n        //     [0.8, ({ value: 0.8 })],\n        // ]);\n\n        // // 如果关键帧的组织是 [时间, 向量] 数组，可以利用解构语法赋值每一条通道曲线。\n        // const vec3KeyFrames = [\n        //     [0.4, new Vec3(1.0, 2.0, 3.0)],\n        //     [0.6, new Vec3(1.0, 2.0, 3.0)],\n        //     [0.8, new Vec3(1.0, 2.0, 3.0)],\n        // ] as [number, Vec3][];\n        // x.curve.assignSorted(vec3KeyFrames.map(([time, vec3]) => [time, { value: vec3.x }]));\n        // y.curve.assignSorted(vec3KeyFrames.map(([time, vec3]) => [time, { value: vec3.y }]));\n        // z.curve.assignSorted(vec3KeyFrames.map(([time, vec3]) => [time, { value: vec3.z }]));\n\n        // // 最后将轨道添加到动画剪辑以应用\n        // animationClip.addTrack(track);\n    }\n}"]}